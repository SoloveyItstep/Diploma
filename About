
Содержание


1.	 Введение …………………………………………………………………. 6

2.	 Глава 1 Общее описание ………………………………………………... 8

2.1.	 Цели и задачи проекта ……………………………………………… 8

2.2.	 Описание проекта …………………………………………………... 9

2.2.1.	Структура сайта ……………………………………………….. 9

2.2.2.	Навигация ……………………………………………………… 9

2.2.3.	Главная страница ……………………………………………… 10

2.2.4.	Каталог товаров ……………………………………………….. 11

2.2.5.	Страница товара ………………………………………………. 11

2.2.6.	Текстовые страницы ………………………………………….. 12

2.2.7.	Контакты ………………………………………………………. 12

2.2.8.	Административная часть сайта ………………………………. 12 

3.	 Глава 2.  Основная структура приложения …………………………… 15

3.1.	  Подключение библиотек …………………………………….......... 15

3.2.	  Дополнительные проекты (Projects) …………………………….... 17

3.2.1.	  Проект  Currency ……………………………………..............  17

3.2.2.	  Проект  Store.Test ……………………………………………. 19

3.2.3.	  Проект  Store.Entity ………………………………….............. 21

3.2.4.	  Проект  Store.Repository …………………………….............. 24

      4.3.  Проект  AppleStore (структура) ………………………………….. 28

4.3.1.	 Структура директорий ………………………….………... 28

4.3.2.	 Используемые паттерны ……………………………......... 30

4.3.3.	 Используемые библиотеки (фреймворки) ……………..... 36

5.	Глава 3.  Проект AppleStore (VS)  ………………………………….... 37

5.1.	 Сервисные файлы и директории ……………………................ 37

5.1.1.	 Класс Startup ……………………………………………..... 37

5.1.2.	 Файл gulpfile.js …………………………………………….. 38

5.1.3.	Файл project.json ………………………………………….... 38

5.1.4.	Директория ViewModels …………………………………... 39

5.1.5.	Директория Services ……………………………………….. 41

5.1.6.	Директория Model …………………………………………. 42

5.1.7.	Директория Migrations …………………………………….. 42

5.1.8.	Директория DataServices …………………………………... 42

6.	Заключение ……………………………………………………………. 46

7.	Перечень условных обозначений ……………………………………. 48

8.	Лист замечаний ……………………………………………………….. 50

9.	Описание необходимых технических средств ……………………… 51

10.	Используемые источники ……………………………………………. 53







Введение

Сайт-магазин «VS» разработан на технологии  Microsoft ASP.NET 5 (Active Server Page for .NET), также называемая ASP.NET vNext . На данный момент технология активно развивается.

•	Шаблон ASP.NET MVC помогает веб-разработчикам создавать веб-сайты, соответствующие стандартам. Эти веб-сайты легко поддерживать, поскольку благодаря использованию шаблона "модель-представление-контроллер" (MVC) уменьшается зависимость между уровнями приложения. 
•	Шаблон MVC обеспечивает возможность полного контроля над разметкой страницы. 
•	ASP.NET MVC расширяет возможности тестирования, поскольку поддерживает разработку, управляемую тестированием (TDD).
•	Веб-сайты, созданные с помощью ASP.NET MVC, имеют модульную архитектуру. Модульная архитектура позволяет членам команды разработчиков работать над различными модулями независимо друг от друга. Например, разработчики могут работать над уровнями модели и контроллера (данные и логика), а дизайнер — над визуальным отображением (представление).

      В последнее время рынок Интернет коммерции развивается. Количество заказов товаров через интернет выросло на 30% по сравнению с прошлым годом. С появление 3G технологий в Украине, пользователи стали чаще использовать мобильные технологи для покупок в Интернете. Что в свою очередь повлияло на широкий спрос создания on-line магазинов. 

      Покупки в Интернете стали обычным явлением, и вопрос не стоит, зачем создавать, а как создать удобный для пользователя и обеспечивающий хорошую конверсию магазин.

      За последние несколько лет техника Apple пользуется спросом среди потребителей. Появляются много Интернет магазинов, которые создаются на базе различных фреймворков и шаблонов. Но не все они являются достаточно удобными для пользователя и многие из них не отражают главную идею компании: лаконичность в дизайне и полноценность функционала. Именно поэтому была выбрана именно эта тема для реализации. 
 
      В интернет магазине, возможно реализовать современные технологии, такие как:
      - C#
      - ASP.NET MVC 6.
      - Entity Framework 7.
      - AngularJS.
      - AngularJS Animate
      - Bootstrap.
      - JQuery.
      - HTML 5.
      - CSS 3.
      - XUnit.net (система тестирования)
- SignalR
     
Интернет рынок, на данный момент, наполнен разновидностью Интернет магазинов во всевозможных отраслях коммерции и не только. К началу 2016 года технология для интернет разработки на языке C# выросла в разы. К сайтам, написанным на данном языке программирования, относятся такие как StackOverflow, CodeProject, DNNsoftware, Chanel9 и т.д.














 
Глава 1  Общее описание

Цели и задачи проекта

Основная цель этого проекта это создание функционального Интернет - магазина. Дизайн и программные решения были разработаны таким образом, чтоб сделать этот ресурс максимально удобным как для покупателей магазина, так и для персонала.

Перед разработчиком стояла задача использовать современные технологии Web-разработки (C#, ASP.NET MVC 6,  Entity Framework 7, AngularJS, AngularJS Animate, Bootstrap, JQuery, HTML 5, CSS 3, XUnit.net и SignalR) в создании полнофункционального ресурса для Интернет коммерции.

Работающий сайт — это в высшей степени эффективный инструмент торговли — он способен захватывать внимание аудитории. Как и любой другой маркетинговый инструмент, основанный на принципе непосредственного отклика, прежде всего он должен заинтриговать посетителя, а затем подвигнуть его на определенные действия. Однако многие игнорируют эту особенность, что часто приводит к тому, что посетители не задерживаются на сайте надолго и покидают его, едва зайдя. Такие сайты, пусть даже содержащие иногда огромное количество полезных советов и статей, практически никогда не достигают предполагаемого уровня посещаемости, не говоря уже о продажах. 

Сделав всего несколько изменений, простой сайт может превратиться  в более надежный и эффективный инструмент. Важно помнить, что каждый день на  потенциальных клиентов обрушивается поток информации и различных рекламных сообщений, и для завоевания их внимания существует предельно жесткая конкуренция. Сайт, способный привлечь внимание и вызвать любопытство, побудит клиентов не только просмотреть оставшиеся страницы и совершить покупки, но и снова посетить его через некоторое время, а также рекомендовать своим друзьям и знакомым. 





Описание проекта

  Структура сайта
   
Структура продумана, чтобы сделать сайт удобным и простым для пользователя. В три клика покупатель может совершить покупку. 
Структура интернет – магазина:
-	Главная
-	Каталог товаров
		• Подкатегории (Mac, iPhone, iPad, iPod, Watch, TV, Accessories)
• Товары
-	Оплата
-	Доставка
-	Контакты
-	Административная часть сайта
 
Навигация

Навигация на сайте представлена на панели в правом верхнем углу. Иконка «гамбургер меню» открывает меню со ссылками переходами на все основные разделы сайта.  Меню состоит из двух блоков: сервисное меню – текстовые страницы, которые описывают, как произвести отплату, варианты доставки и контакты; меню каталога – ссылки переходы на основные разделы каталога. 

Иконка «поиска» при нажатии на нее поле становиться белым, и появляется строка поиска. Модуль поиска позволяет осуществить «умный поиск», то есть, когда пользователь  начинает вводить текст, поисковая строка предлагает варианты выбора. Поиск осуществляется по категориям и названиям товаров.

При нажатии на иконку входа пользователю предлагается авторизоваться, или зарегистрироваться. Формы открывается во всплывающем окне. Для авторизации достаточно вести адрес электронной почты и пароль, или войти с помощью социальных сетей. При нажатии на ссылку «регистрация» открывается форма ввода данных: ФИО, телефон, e-mail, город, адрес, пароль. При вводе данных присутствует валидация. После нажатия на кнопку «Зарегистрироваться», на указанный пользователем электронный ящик будет отправлено письмо, содержащее ссылку, перейдя по которой пользователь сможет активировать свой аккаунт. В случае, если пользователь авторизовался, при следующем посещении сайта, ему нет необходимости проходить повторно процедуру авторизации. Когда пользователь авторизирован и нажимает на иконку пользователя, тогда во всплывающем окне открывается подсказка с именем и ссылкой выйти из аккаунта. Также, иконка имеет два вида: после авторизации она закрашивается и дает возможность с первого взгляда определить, что выполнен вход.
Корзина – при нажатии открывается всплывающее окно с товарами, где пользователь может изменить количество, перейти к оформлению, удалить товар из корзины, увидеть итоговую сумму заказа. Как и при авторизации, если в корзине есть товары - иконка закрашивается. Закрыть окно можно нажав на крестик, кликнуть на пустое поле за пределами окна или нажать кнопку «продолжить покупки».

Еn (Ru) – нажав на иконку, пользователь может выбрать язык интерфейса. Вместе с языком меняется валюта, в которой выводится цена за товары. Система работает на двух языках: английский (цены представлены в долларах) и русский (гривны по курсу продажи валюты Приват Банка).

Также, немаловажным навигационным элементов является футер. В нем представлен каталог товаров в виде ссылок. На типовых страницах под имиджевым баннером размещены «хлебные крошки», которые помогают пользователю, ориентироваться в какой части сайта он находится. Это в разы улучшает удобство использования сайта и дает возможность вернуться к предыдущему шагу.

Главная страница

Главная страница, выполнена в минималистичном дизайне присущий продуктам Apple, который подчеркивается ненавязчивой и отзывчивой анимацией.

Что видит пользователь, попадая на главную страницу? 

Баннеры информируют пользователя обо всех акциях, новинках и важных событиях происходящих в магазине, которые могут его заинтересовать. Далее представлены категории товаров. Так как структура магазина достаточно простая, потребителю будет легко сориентироваться, куда нужно двигаться дальше для совершения покупки. При проектировании сайта сохранена логика офлайновых торговых площадок. Покупатель, входя в магазин, видит навигацию размещения определенных групп товаров. Так, что достаточно легко сориентироваться и «пройти к витрине» с интересующими товарами. Было продумано несколько альтернативных путей, которыми может воспользоваться посетитель, чтоб выбрать категорию товара:
1.	Каталог категорий на главной странице
2.	Выпадающее меню
3.	В футере размещены ссылки на категории товаров. 


Каталог товаров

Каталог товаров имеет один уровень вложенности. Список категорий графически представлен на главной странице, также в ссылочном исполнении в главном меню и футере. 

На странице подкатегорий товаров представлены товары. В левой части страницы, открывается меню с фильтрами, что поможет пользователю подобрать нужные параметры устройства, которое он хочет приобрести. Для каждой подкатегории это свой набор фильтров. Также,  предусмотрена возможность сбросить все фильтры и вернуться к просмотру всего ассортимента.

В кратком отображении товара, представлена такая информация: изображение товара, название и цена. При наведении область товара затемняется и появляется краткая информация о товаре, а также кнопка «Узнать больше». При нажатии на блок, пользователь попадает на страницу товара.

На странице с большим количеством товаров, предусмотрена пагинация. При чем, пользователь может добавить еще до восьми элементов, либо перейти на следующую страницу. Пагинация работает без перезагрузки страницы.

Страница товара

На странице товара представлена вся подробная информация о товаре. В верхней части размещен навигационный элемент «Вернуться к выбору товара», что позволяет пользователю вернуться назад в каталог. Также, для удобства такой же элемент размещен внизу страницы, после информации, что облегчит возвращение к каталогу, если товар не подошел.

Первое, что видит пользователь на этой странице это название, галерею с фотографиями, цену, кнопку «Добавить в корзину», информацию о доставке и оплате.  При прокрутке пользователь может просмотреть подробные характеристики товара.


Текстовые страницы

Под текстовыми страницами подразумеваются страницы сайта, содержимое которых, можно представить в виде обычной текстовой страницы, при этом не требуется привлечение дополнительных программных решений.
Данный тип страницы может содержать таблицы, изображения и текст. 

                              Контакты
Контакты (стандартная текстовая страница + форма обратной связи);
Форма обратной связи содержит следующие поля:
Ф.И.О. *имя
E-mail *
Контактный телефон *
Текст сообщения
    
Административная часть сайта

Административная панель сайта разработана для администраторов и персонала магазина. С ее помощью можно просмотреть, редактировать или удалить заказы, товары. Также, предусмотрена работа с данными пользователей. 

Визуальная часть отличается от клиентской части сайта. Административная часть разработана, в основном, с помощью библиотеки Bootstrap - для быстрой работы и AngularJS – для работы с технологией SignalR для соединения по сокету с сервером, а также для работы с данными.

Первая страница в административной части сайта – это страница заказов. На данной странице AngularJS открывает соединение по сокету для получения заказов от клиентов в режиме реального времени. При появлении нового заказа – заказ добавляется в начало списка. В заказе отображается:  

-	Номер заказа;
-	Дата оформления заказа пользователем;
-	Имя пользователя;
-	Количество позиций товаров;
-	Общая сумма;
-	Способ оплаты;
-	Способ доставки;
-	Адрес доставки;
-	Статус заказа.

При появлении нового заказа, администратор может перейти на страницу заказа, нажав кнопку статуса «Новый», или «В обработке». При нажатии на кнопку «новый» статус автоматически меняется на «в обработке». Перейдя на страницу заказа, можно редактировать количество, удалить или добавить новую позицию. Дополнительно, можно изменить данные пользователя, удалить заказ и отметить как «выполнен». 

На странице «Каталог товаров» представлены все товары, которые сгруппированы по категориям. При открытии вкладки по умолчанию открывается категория «Watch». Администратор может посмотреть уже существующие товары в таблице, или добавить новый, нажав на кнопку «добавить товар». В таблице представлены основные сведения о товаре: 

-	Номер товара;
-	Модель;
-	Тип;
-	Цена;
-	Кнопка «Редактировать»
-	Кнопка «Удалить»

При нажатии на кнопку «Редактировать» открывается страница редактирования, где можно менять, как основные данные, так и характеристики товара. После изменения необходимых полей нужно нажать кнопку «Сохранить изменения». 

При нажатии на кнопку «Добавить товар» открывается новая страница. При выборе категории подбирается шаблон с готовыми полями для создания товара. Реализована возможность добавлять фотографии. Также, есть возможность редактировать, добавлять и удалять поля. После заполнения полей нужно нажать кнопку «Создать».

Последний раздел – это список пользователей. На этой странице, в таблице представлены данные о зарегистрированных пользователях. Основные поля:

-	Имя пользователя;
-	Email;
-	Город;
-	Адрес;
-	Телефон;
-	Статус.

Поле статус редактируется пользователем со статусом «Суперадмин». У него есть права назначать обычных пользователей «Администраторами», или «Супер администраторами». При регистрации пользователю присваивается статус «Клиент».



















 
Глава 2  Основная структура приложения

		Подключение библиотек

Структура ASP.NET 5 отличается от своего предшественника. Отличаются как расположение, стартовый класс, так и подключение библиотек. На самом деле здесь их два:

 - Классический (в Solution Explorer, правой кнопкой по «References» -> Add Reference)

- Продвинутый (ручной), используя файлик project.json.
Давайте рассмотрим структуру project.json по блокам в данном проекте (Рис.4.1.1).

 
		Рис. 4.1.1. Webroot

webroot - директория на сервере, куда публикуются приложения: webroot является публичным хранилищем.
version - это версия приложения. Никакой связи с версией CRL или еще чего-то не имеет.

dependencies – это хранилище зависимостей библиотек с приложением (Рис. 4.1.2).

 
				Рис. 4.1.2 Dependencies

Тут-то как раз и подключаются необходимые для MVC библиотеки. Intellisense -  подсказывает версию библиотек, так что затруднений это не предоставит.

И тут начинается магия: как только ввели новую строку и сохранили изменения, вы можете заметить, как в Solution Explorer раздел References начинает обновляться (пример на Рис.4.1.3)

 
		Рис. 4.1.3 References

Visual Studio автоматически докачивает только что добавленную библиотеку из nuget и сохраняет ее в кеш (и, соответственно, добавляет в проект). Если вы сотрете только что созданную строку в project.json, Visual Studio уберет ее из References в вашем проекте, но при повторном добавлении этой строки, библиотека подключится уже из кэша, без закачки из онлайн репозитория.

Также что в References нет привычной простыни из подключенных библиотек. Все они спрятаны в разделы DNX 4.5.1 и DNX Core 5.0 в виде дерева. Дерево — это зависимости одних библиотек от других.

Вопрос: откуда взялся DNX 4.5.1 и DNX Core 5.0 в нашем проекте? Опять таки, из project.json (Рис.4.1.4)

 
		Рис.4.1.4 DNX 4.5.1 и DNX Core 5.0

Если мы удалим, например, строчку с dnx451, то весь раздел DNX 4.5.1 пропадет из References в Solution Explorer. Иными словами, раздел «frameworks» указывает, под какие фреймворки будет собран наш проект. Причем в каждом из них можно создать свой набор зависимостей аналогично тому, как это делалось выше, там, где мы добавляли библиотеку MVC.

commands  - это команда запускает dnx для старта вашего приложения (Рис.4.1.5).

 
				Рис.4.1.5 Commands

publishExclude — компоненты, которые не нужно включать в пакет публикации (Рис.4.1.6).
exclude — компоненты, которые нужно игнорировать при компиляции (Рис.4.1.6).

 
		Рис.4.1.6  Exclude  и  publishExclude

Дополнительные проекты (Projects)

В проекте имеются дополнительные проекты, также называемые как Project. Их всего 4, а именно:
- Currency
- Store.Entity
- Store.Repository
- Store.Test

Все эти проекты являются «Class Library (Package)», за исключением проекта Currency. Проект Currency – это Console Application (Package): консольное приложение. Проекты собираются в библиотеки (.dll).  Рассмотрим их поподробнее.

Проект  Currency

По своей сути Currency является консольным приложением, предназначенным для кроссплатформенного проекта ASP.NET 5, но при сборке собирается в библиотеку классов C# (для более подробной информации – что такое “Console Application (Package)”, смотрите вступительное описание к данному проекту). Проект Currency - это вспомогательная библиотека для удаленного получения курса доллара США в эквиваленте Украинской гривны (сумма гривен за один доллар). API запросы отправляются на сайт «Приват Банка» в виде адресной строки с текущей датой в конце. Ответ на запрос возвращаются в формате JSON. Полученный ответ парсится (разбирается на определенные части) для получения курса продажи доллара банком. В случае отсутствия данных по текущей дате, запросы на сайт Приват Банка вступают в рекурсию до момента получения последней валидной записи в базе данных Приват Банка.

Проект состоит из:

- класс CurrencyUSD
- класс Program (класс консольного приложения)
- интерфейс ICurrencyUSD
- папка Entity



Интерфейс ICurrencyUSD (см. описание класса 4.2.1.1) предназначен для встроенного в проект VS внедрения зависимостей (Dependency Injection). Класс CurrencyUSD в свою очередь реализует его.

public interface ICurrencyUSD
    {
        CultureInfo culture { get; }
        String currentDate { get; }
        String CurrentDateUrl { get; }
        String Url { get; }
        String GetCurrentDateCurrency();
        Data GetLastCurrency(DateTime date);
        String GetRequest(String url);
        Data data { get; set; }
}
		Описание 4.2.1.1 интерфейс ICurrencyUSD


В папке Entity находятся классы:

- Data
- ExchangeRate
- UserServices

Классы UserServices (см. описание класса 4.2.1.2) и ExchangeRate (см. описание класса 4.2.1.3)  – являются классами соответствующими данным приходящих в ответе с сервера Приват Банка

public class UserServices
    {
        public DateTime date { get; set; }
        public string bank { get; set; }
        public int baseCurrency { get; set; }
        public string baseCurrencyLit { get; set; }
    public List<ExchangeRate> exchangeRate { get; set; }
}
			Описание 4.2.1.2 класс UserServices

public class ExchangeRate
    {
        public string baseCurrency { get; set; }
        public string currency { get; set; }
        public decimal saleRateNB { get; set; }
        public decimal purchaseRateNB { get; set; }
        public decimal saleRate { get; set; }
        public decimal purchaseRate { get; set; }
}
		Описание 4.2.1.3 класс ExchangeRate

Класс Data в результате отравляется в web проект VS для обработки (см. описание класса 4.2.1.4). В Классе Data находятся два поля: строковое (currency) и дата (date).

public class Data
    {
        public String curency { get; set; }
        public DateTime date { get; set; }
}
		описание 4.2.1.4 класс Data

В строковое поле currency записывается курс гривны за один доллар. В поле date записывается последняя дата записи на сервере Приват Банка.


Проект  Store.Test

Как уже понятно из заголовка – этот проект предназначен для Unit тестов. Так как ASP.NET 5 – это кроссплатформенная среда и ядро ASP.NET полностью переписано (см. описание к данной работе), также и обычные Unit тесты здесь невозможны. Вместо Unit тестов в приложениях ASP.NET 5 стали возможны xUnit тесты, которые чем-то даже превосходят своих предшественников Unit test. А именно: их можно реализовывать также легко лишь обозначив нужный метод атрибутом [Fact], но результат данного теста не зависит от конечного результата, а от статического класса Assert находящегося в пространстве имен Xunit. Следуя из этого, класс Assert может быть реализован множество раз на протяжении теста.

В проекте находится директория UnitOfWorkTestFolder для хранения поддиректорий с классами для тестирования запросов в БД.

Пример xUnit тестов приведен в описании класса 4.2.2.1.

public class iPadTest
    {
        IUnitOfWork unOfWork;
        IUnitOfWork unitOfWork { get {
                if(unOfWork == null)
                {
                    IStoreContext context = new StoreContext();
                    unOfWork = new UnitOfWork(context,
                    new AppleRepository(context),
                    new CategoriesRepository(context),
                    new ProductDetailsRepository(context),
                    new DetailNamesRepository(context),
                    new AppleColorRepository(context),
                    new ImageRepository(context),
                    new ColorRepository(context),
                    new CurrencyRepository(context));
                }
                return unOfWork;
            } }

        [Fact]
        public async void FirstTest()
        {
            Categories category = await unitOfWork.Categories
                .Find(cat => cat.CategoryName == "iPad");
            Assert.NotNull(category);

            var apple = await unitOfWork.Apple.Find(a => a.AppleID == 7);
            Assert.NotNull(apple);

            var name = await unitOfWork.DetailNames.Find(d => d.DetailNamesID == 1);

            var details = new ProductDetails()
            {
                DetailNames = name,
                Measure = "inch",
                Value = "241.2x185.7x9.4",
                Other = "",
                Apple = apple,
                AppleID = apple.AppleID
            };

            unitOfWork.ProductDetails.Add(details);
            Int32 result = unitOfWork.Commit();
            Assert.Equal(result, 1);

    }
}
		Описание 4.2.2.1 класс iPadTest

В описании класса, приведенным выше предоставляется пример тестирования класса UnitOfWork для работы с БД. В первых строках происходит объявление класса UnitOfWork. 

Метод FirstTest и составляет собой сам тест. Метод обозначен атрибутом [Fact] предназначенный для определения метода как тестового. Первоначально из БД добывается категория с помощью метода Find. Через метод Find с помощью лямбда выражения производится поиск определенной категории (в данном случае «iPad»). После чего производится первый тест. Тесты производятся не по результирующему значению, а по совокупности соответствий в статических методах Assert, первый из которых NotNull: проверка на не пустоту объекта или переменной.

Следующий тест производится подобно предыдущему, но на этот раз с классом (таблицей БД) под названием Apple и поиск ведется по ключу (Primary key), а не по имени. Подобно предыдущему тесту – полученный ответ на запрос проверяется на не пустоту.

Следующим тестом производится поиск с классом (таблицей БД) под названием DetailNames. После чего создается объект класса (таблицы) ProductDetails и сохраняется в БД с помощью метода Commit находящемся в классе UnitOfWork. Метод Commit возвращает цифровое значение как результат выполненной работы. По этому следующий тест производится сравнивая значения (метод Equels в статическом классе Assert).


Проект  Store.Entity

Проект Store.Entity – это классы модели базы данных приложения VS, а также контекст (DbContext). В данном проекте находятся классы, связанные с товарами и курсом валют. Просмотрим их подробнее.

 
			Рис. 4.2.3.1 структура классов проекта Store.Entity
На рисунке 4.2.3.1 показаны классы, составляющие собой модель БД.

Класс Apple представляет собой базовую таблицу товара со своими зависимостями (см. описание класса 4.2.3.1).

public class Apple
    {
        public Int32 AppleID { get; set; }

        [StringLength(maximumLength: 30)]
        public String Subcategory { get; set; }

        [StringLength(maximumLength: 15)]
        public String Construction { get; set; }

        [StringLength(maximumLength: 15)]
        public String Type { get; set; }

        [StringLength(maximumLength: 30)]
        public String Model { get; set; }

        [StringLength(maximumLength: 30)]
        public String Name { get; set; }
        public Decimal Price { get; set; }

        [StringLength(maximumLength: 100)]
        public String Url { get; set; }

        public virtual ICollection<AppleColor> AppleColor { get; set; }
        public virtual ICollection<Image> AppleImage { get; set; }
        public virtual ICollection<ProductDetails> ProductDetails { get; set; }
        public virtual Categories Categories { get; set; }
}
			Описание 4.2.3.1 класс Apple

Как показано в описании класс Apple содержит множество полей и зависимостей с другими классами.

Поля класса Apple:
-	AppleID является числовым и внутренним ключом (Primary key).
-	Subcategory является строковым с максимальной длинной в 30 символов.
-	Construction является строковым с максимальной длинной в 15 символов.
-	Type является строковым с максимальной длинной в 15 символов.
-	Subcategory является строковым с максимальной длинной в 30 символов.
-	Model является строковым с максимальной длинной в 30 символов.
-	Name является строковым с максимальной длинной в 30 символов.
-	Price является числовым, десятичным.
-	Url является строковым с максимальной длинной в 100 символов.

Виртуальные поля (virtual) определяют зависимости с другими классами (таблицами), то есть являются внешними ключами (FOREIGN KEY):

- поле AppleColor является связью с классом Color и соотношением многие ко многим, таблица AppleColor является промежуточной между двумя таблицами. Соответственно таблица Color имеет соотношение с таблицей AppleColor многие ко многим
- поле AppleImage является связью с классом Image и соотношением один ко многим.
- поле ProductDetails является связью с классом ProductDetails и соотношением один ко многим.
- поле Categories является связью с классом Categories и соотношением многие к одному.

Класс ProductDetails также имеет связи с другими классами и одна из них связь с классом DetailNames с соотношением многие к одному.

Класс Currency в зависимостях не нуждается. Класс Currency содержит лишь поля даты, курса валюты и первичного ключа. Поля даты и курса валют являются строковыми.

Связи между описанными таблицами (классами) приведены на рисунке 4.2.3.2. 

 
				Рис. 4.2.3.2 связи таблиц БД.
Также в проекте находится папка с интерфейсом (IStoreContext)           (см. описание к классу 4.2.3.1) и контекстом (StoreContext) реализующим его. По сути, IStoreContext необходим для дальнейшего объявления с помощью DI.

public interface IStoreContext
    {
        DbSet<Apple> Apple { get; set; }
        DbSet<Categories> Categories { get; set; }
        DbSet<AppleColor> AppleColor { get; set; }
        DbSet<Color> Color { get; set; }
        DbSet<ProductDetails> ProductDetails { get; set; }
        DbSet<DetailNames> DetailNames { get; set; }
        DbSet<Image> Image { get; set; }
        DbSet<Currency> Currency { get; set; }
        Int32 Save();
        Task<Int32> SaveAsync();
}
 			Описание 4.2.3.1 интерфейс IStoreContext

DbSet представляет коллекцию всех сущностей указанного типа, которые содержатся в контексте или могут быть запрошены из базы данных. Объекты DbSet создается из DbContext с помощью метода DbContext.Set.

Проект  Store.Repository

В данном проекте реализован паттерн, который позволяет с большей легкостью проводить транзакции с базой данных.


Папка Repository содержит вложенную папку Interfaces с интерфейсами:
- IAppleColorRepository
- IAppleRepository
- ICategoriesRepository
- IColorRepository
- ICurrencyRepository
- IDetailNamesRepository
- IImageRepository
- IProductDetailsRepository
- IRepository

Все интерфейсы параметризированы шаблонным типом. Общие (или параметризованные) типы (generics) позволяют при описании классов, структур, методов и интерфейсов использовать параметризованные параметры (не указывать тип параметра в момент написания кода). Тип параметра определяется в момент объявления переменной соответствующего типа. Таким образом, можно создать некоторый общий элемент, тип который можно использовать в дальнейшем для данных различных типов.

public interface IRepository<T> where T : class
    {
        Task<IEnumerable<T>> GetAll();
        Task<T[]> GetAllInclude(params Expression<Func<T,Object>>[] include);
        Task<T> GetFirst();
        Task<T> Find(Expression<Func<T, Boolean>> predicate);
        Task<T[]> FindAllInclude(Expression<Func<T, Boolean>> predicate);

        void Add(T entity);
        void Remove(T entity);
        Int32 Save();
        Task<Int32> SaveAsync();
}
		Описание 4.2.4.1 интерфейс IRepository

Все интерфейсы (за исключением IRepository) наследуют интерфейс IRepository (см. описание к классу 4.2.4.1), но дополнительно объявляют методы для собственной таблицы соответственно. К примеру:

Интерфейс IAppleRepository содержит шаблонные методы для их использования в реализующих их классах. Но этих методов не достаточно во многих репозиториях. К примеру, интерфейс IAppleRepository (см. описание к классу 4.2.4.2) определяет методы GetFirstInclude для получения первого элемента с вложенными зависимостями.

public interface IAppleRepository<T>: IRepository<T> where T : class
    {
        Task<T> GetFirstInclude(Expression<Func<T, Boolean>> include);
        Task<T> GetOneInclude(Int32 id);
}
			Описание 4.2.4.2 интерфейс IAppleRepository

Все интерфейсы необходимы для дальнейшего объявления с помощью DI. Пример реализации интерфейсов приведен в классе AppleRepository (см. описание к классу 4.2.4.3)

public class AppleRepository : Repository<Apple>, IAppleRepository<Apple>
    {
        protected readonly new IStoreContext context;
        public AppleRepository(IStoreContext context)
            :base(context)
        {
            this.context = context;
        }
        public async Task<Apple> GetFirstInclude(Expression<Func<Apple, bool>> include)
        {
            return await (context as DbContext).Set<Apple>().Where(include)
                .Include(a => a.Categories)
                .Include(a => a.AppleColor).ThenInclude(ac => ac.Color)
                .Include(a => a.ProductDetails).ThenInclude(a => a.DetailNames)
                .Include(a => a.AppleImage).FirstOrDefaultAsync();
        }

        public async Task<Apple> GetOneInclude(Int32 id)
        {
           var apple = await (context as DbContext).Set<Apple>()
   .Where(a => a.AppleID == id)
                .Include(a => a.ProductDetails).ThenInclude(a => a.DetailNames)
                .Include(a => a.AppleColor).ThenInclude(a => a.Color)
                .Include(a => a.AppleImage).FirstOrDefaultAsync();
            return apple;
        }
}
			Описание 4.2.4.3 класс AppleRepository

В приведенном выше примере, в методе GetFirstInclude, показан запрос к БД для получения первого элемента соответствующего выражению передаваемого в метод (в данном приложении передаваемые выражения, в основном, являются лямбда выражениями). Приведение объекта context к типу DbContext необходим для получения доступа к методам Include? ThenInclude и FirstOrDefaltAsync. Методы Include и ThenInclude позволяют добавить вложенные таблицы связанные с данным элементом. К примеру у элемента Apple есть параметры (ProductDetails), цвета (Color), картинки (AppleImage) и т.д.

Репозитории основаны на потоках (async await) для более быстрой обработки запросов к базе данных. Таким образом, пользователь, сделавший первый запрос, не будет заставлять других пользователей ждать освободившегося потока для запроса к базе данных.

Второй папкой присутствующей в проекте Store.Repository является UnitOfWorks. В данной папке находятся класс (UnitOfWork) и интерфейс (IUnitOfWork). Пример реализации интерфейса IUnitOfWork показан в описании класса 4.2.4.4.

public interface IUnitOfWork
    {
        IAppleRepository<Apple> Apple { get; set; }
        ICategoriesRepository<Categories> Categories { get; set; }
        IAppleColorRepository<AppleColor> AppleColor { get; set; }
        IColorRepository<Color> Color { get; set; }
        IProductDetailsRepository<ProductDetails> ProductDetails { get; set; }
        IDetailNamesRepository<DetailNames> DetailNames { get; set; }
        IImageRepository<Image> Image { get; set; }
        ICurrencyRepository<Currency> Currency { get; set; }
        Int32 Commit();
        Task<Int32> CommitAsync();
        Apple[] GetByOneFromCategories();
        Task<Apple[]> GetAppleForSearchIncludeCategories();
        Task<Apple[]> FindByCategoryNameInclude
(Expression<Func<Apple, Boolean>> predicate);
        Task<Apple[]> GetAllByCategoryNameInclude(String categoryName);
        Task<Apple[]> GetTwentyByCategoryNameInclude(String categoryName);
        Task<Apple[]> GetAllSkypSexteenByCategoryNameInclude(String categoryName);
        Task<Apple[]> GetCartData(Dictionary<Int32, Int32> cart);
}
				Описание 4.2.4.4 интерфейс IUnitOfWork

В классе UnitOfWork, методы Commit и CommitAsync (Async – в переводе означает «асинхронный») предназначены для сохранения изменения произведенными с БД.

Метод GetByOneFromCategories возвращает по одному элементу с каждой категории в массиве.

Метод GetAppleForSearchIncludeCategories возвращает массив элементов Apple для строки поиска.

Метод FindByCategoryNameInclude возвращает массив элементов, находящихся в определенной категории. Категория определяется передаваемым выражением с именем predicate.

Метод GetAllByCategoryNameInclude возвращает массив элементов, находящихся в категории с определенным именем, передаваемым в метод.

Метод GetAllSkypSexteenByCategoryNameInclude возвращает массив эелементов, находящихся в категории с определенным именем, передаваемым в метод, но пропуская первые 16. Это необходимо для постепенной закачки данных на страницу (об этом описано в следующей главе).

Метод GetCartData возвращает массив элементов находящихся в корзине. Пример метода описан в описании класса 4.2.4.5.

 	  public async Task<Apple[]> GetCartData(Dictionary<int, int> cart)
        {
            var apple = cart.Keys.SelectMany(id => context.Apple
   .Where(ap => ap.AppleID == id)
                       	.Include(ai => ai.AppleImage)
                       	.Include(ai => ai.AppleColor)
                       	.ThenInclude(im => im.Color))
.ToAsyncEnumerable();
            
            return await apple.ToArray();
 }		
Описание 4.2.4.5 метод GetCartData класса UnitOfWork

В метод GetCartData передается словарь Dictionary (массив с элементами – ключ-значение) аналогичному массиву, хранящемуся в сессии приложения. В массиве Cart ключи представляют собой ID элементов из таблицы Apple. В массиве ключей с помощью метода SelectMany, из контекста получает нужный массив полей таблицы Apple с вложенными таблицами, связанными с определенными элементами.

Соответственно класс UnitOfWork реализует интерфейс IUnitOfWork и создает объекты с помощью DI (см. Описание класса 4.2.4.6) в конструкторе класса.

Public UnitOfWork(IstoreContext context,
                  IappleRepository<Apple>  ppleRepository,
                  IcategoriesRepository<Categories> categoriesRepository,
           IproductDetailsRepository<ProductDetails> productDetailsRepository,
                  IdetailNamesRepository<DetailNames> detailNamesReporitory,
                  IappleColorRepository<AppleColor> appleColorRepository,
                  IimageRepository<Image> imageRepository,
                  IcolorRepository<Color> colorRepository,
                  IcurrencyRepository<Currency> currency)
        {
            this.context = context;
            this.Apple =  ppleRepository;
            this.Categories = categoriesRepository;
            this.AppleColor = appleColorRepository;
            this.DetailNames = detailNamesReporitory;
            this.Image = imageRepository;
            this.Color = colorRepository;
            this.ProductDetails = productDetailsRepository;
            this.Currency = currency;
    }
			Описание 4.2.4.6 конструктор класса UnitOfWork

Интерфейс IunitOfWork необходим для дальнейшего объявления класса с помощью DI.


Проект AppleStore (структура)

Структура директорий

Dependencies: содержит два подкаталога Bower и NPM, которые соответствуют двум менеджерам пакетов и в которых определены зависимости, используемые при разработке клиентской части приложения. На рисунке 4.3.1 показан пустой проект.

Controllers: папка для хранения контроллеров, используемых приложением

Migrations: папка для хранения миграций баз данных

Models: папка для хранения моделей

Services: каталог для хранения сервисов и различных вспомогательных классов

DataServices: каталог для хранения вспомогательных классов

ViewModels: папка для хранения моделей, используемых представлениями

Views: каталог для хранения представлений

appsettings.json: хранит конфигурацию приложения

gulpfile.js: файл, который содержит задачи, выполняемые менеджером Gulp при построении проекта

Startup.cs: файл, определяющий класс Startup, с которого начинается работа приложения. То есть это входная точка в приложение.

 
   				Рис. 4.3.1 Структура папок пустого проекта MVC
Используемые паттерны

  Паттерн MVC

Одним из отличительных моментов платформы ASP.NET 5 является применение паттерна MVC. Причем версия MVC-фреймворка, который применяется в ASP.NET 5, имеет номер 6. Поэтому важно не путать ASP.NET MVC 5, который применяется в ASP.NET 4.5/4.6, и MVC 6, который применяется в ASP.NET 5.

Концепция паттерна MVC предполагает разделение приложения на три компонента:
-	Модель (model): описывает используемые в приложении данные, а также логику, которая связана непосредственно с данными, например, логику валидации данных. Как правило, объекты моделей хранятся в базе данных
-	Представление (view): визуальная часть или пользовательский интерфейс, нередко html-страница, через который пользователь взаимодействует с приложением
-	Контроллер (controller): центральный компонент MVC, который обеспечивает связь между пользователем и приложением, представлением и хранилищем данных. Он получает вводимые пользователем данные и обрабатывает их. И в зависимости от результатов обработки отправляет пользователю определенный вывод, например, в виде представления, наполненного данными моделей.
-	
Отношения между компонентами паттерна описаны на рисунке 4.3.2.1.

 
 
				Рис 4.3.2.1 Паттерн MVC
  В этой схеме модель является независимым компонентом – любые изменения контроллера или представления никак не влияют на модель. Контроллер и представление являются относительно независимыми компонентами. Так, из представления можно обращаться к определенному контроллеру, а из контроллера генерировать представления, но при этом нередко их можно изменять независимо друг от друга.

Паттерн Repository

Паттерн Repository (рис. 4.3.2.2) посредничает между слоем области определения и слоем распределения данных, работая, как обычная коллекция объектов области определения. Объекты-клиенты создают описание запроса декларативно и направляют их к объекту-репозиторию (Repository) для обработки. Объекты могут быть добавлены или удалены из репозитория, как будто они формируют простую коллекцию объектов. А код распределения данных, скрытый в объекте Repository, позаботится о соответствующих операциях в незаметно для разработчика. В двух словах, паттерн Repository инкапсулирует объекты, представленные в хранилище данных и операции, производимые над ними, предоставляя более объектно-ориентированное представление реальных данных. Repository также преследует цель достижения полного разделения и односторонней зависимости между уровнями области определения и распределения данных.

 
					Рис. 4.3.2.2 паттерн Repository


	Допустим, у нас есть одно подключение к базе данных MS Sql Server.
Однако, что если в какой-то момент времени мы захотим сменить подключение с MS Sql на другое – например, к БД MySQL или MongoDB. При стандартном подходе даже в небольшом приложении, осуществляющем выборку, добавление, изменение и удаление данных, нам бы пришлось сделать большое количество изменений. Либо в процессе работы программисты в зависимости от разных условий мы хотим использовать два разных подключения. Таким образом, репозиторий добавляет программе гибкость при работе с разными типами подключений.


Паттерн Abstract Factory

Паттерн Abstract Factory (см. рисунок 4.3.2.3) - предоставляет клиенту интерфейс (набор методов) для создания семейств взаимосвязанных или взаимозависимых объектов-продуктов, при этом скрывает от клиента информацию о конкретных классах создаваемых объектов-продуктов.

 
					Рис. 4.3.2.3 Паттерн Abstract Factory

В системе создается (чаще всего) только один экземпляр конкретной фабрики. Задачей конкретной фабрики является создание объектов продуктов, входящих в определенное семейство.

 При создании экземпляра клиента, клиент конфигурируется экземпляром конкретной фабрики (ссылка на экземпляр фабрики передается в качестве аргумента конструктора клиента).

 Абстрактный класс AbstractFactory передает ответственность за создание объектов-продуктов производным конкретным фабрикам.


Паттерн Facade

 
Рис. 4.3.2.4. Паттерн Facade

Шаблон фасад  - структурный паттерн проектирования, позволяющий скрыть сложность системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

Определить одну точку взаимодействия с подсистемой — фасадный объект, обеспечивающий общий интерфейс с подсистемой, и возложить на него обязанность по взаимодействию с её компонентами. Фасад — это внешний объект, обеспечивающий единственную точку входа для служб подсистемы. Реализация других компонентов подсистемы закрыта и не видна внешним компонентам.

Шаблон применяется для установки некоторого рода политики по отношению к другой группе объектов. Если политика должна быть яркой и заметной, следует воспользоваться услугами шаблона Фасад. Если же необходимо обеспечить скрытность и аккуратность (прозрачность), более подходящим выбором является шаблон Заместитель (Proxy).

Используемые библиотеки (фреймворки)

В данном разделе находятся описания для библиотек, использованных в этом приложении. К таким библиотекам относятся:

- JQuery
- Bootstrap
- AngularJS

JQuery

jQuery — библиотека JavaScript, фокусирующаяся на взаимодействии JavaScript и HTML. Библиотека jQuery помогает легко получать доступ к любому элементу DOM, обращаться к атрибутам и содержимому элементов DOM, манипулировать ими. Также библиотека jQuery предоставляет удобный API для работы с AJAX.

Возможности библиотеки JQuery:
- движок кросбраузерных CSS-селекторов Sizzle, выделившийся в отдельный проект
- переход по дереву DOM, включая поддержку XPath как плагина.
- события
- AJAX дополнения
- JavaScript плагины

Bootstrap

Bootstrap  — свободный набор инструментов для создания сайтов и веб-приложений. Включает в себя HTML и CSS шаблоны оформления для типографики, веб-форм, кнопок, меток, блоков навигации и прочих компонентов веб-интерфейса, включая JavaScript-расширения.

Bootstrap использует самые современные наработки в области CSS и HTML, поэтому необходимо быть внимательным при поддержке старых браузеров.

Основные инструменты Bootstrap:

- Сетки — заранее заданные размеры колонок, которые можно сразу же использовать, например ширина колонки 140px относится к классу .span2 (.col-md-2 в третьей версии фреймворка), который можно использовать в CSS описании документа.
- Шаблоны — Фиксированный или резиновый шаблон документа.
- Типографика — Описания шрифтов, определение некоторых классов для шрифтов, таких как код, цитаты и т. п.
- Медиа — Представляет некоторое управление изображениями и Видео.
- Таблицы — Средства оформления таблиц, вплоть до добавления функциональности сортировки.
- Формы — Классы для оформления форм и некоторых событий происходящих с ними.
- Навигация — Классы оформления для Табов, Вкладок, Страничности, Меню и Тулбара.
- Алерты — Оформление диалоговых окон, Подсказок и Всплывающих окон.

AngularJS

AngularJS — JavaScript-фреймворк с открытым исходным кодом. Предназначен для разработки одностраничных приложений. Его цель — расширение браузерных приложений на основе MVC шаблона, а также упрощение тестирования и разработки.

Фреймворк работает с HTML, содержащим дополнительные пользовательские атрибуты, которые описываются директивами, и связывает ввод или вывод области страницы с моделью, представляющей собой обычные переменные JavaScript. Значения этих переменных задаются вручную или извлекаются из статических или динамических JSON-данных.

Популярные AngularJS директивы:
С помощью директив AngularJS можно создавать пользовательские HTML-теги и атрибуты, чтобы добавить поведение некоторым элементам.
ng-app - Объявляет элемент корневым для приложения.
ng-bind - Автоматически заменяет текст HTML-элемента на значение переданного выражения.
ng-model - То же что и ng-bind, только обеспечивает двустороннее связывание данных. Изменится содержимое элемента, ангуляр изменит и значение модели. Изменится значение модели, ангуляр изменит текст внутри элемента.
ng-class - Определяет классы для динамической загрузки.
ng-controller - Определяет JavaScript-контроллер для вычисления HTML-выражений.
ng-repeat - Создает экземпляр для каждого элемента из коллекции.
ng-show и ng-hide - Показывает или скрывает элемент в зависимости от значения логического выражения.
ng-switch - Создает экземпляр шаблона из множества вариантов, в зависимости от значения выражения.
ng-view - базовая директива, отвечает за обработку маршрутов, которые принимают JSON перед отображением шаблонов, управляемых указанными контроллерами.
























 
Глава 3 Проект AppleStore (VS)

Данный проект является главным в данном приложении. Проект AppleStore можно разделить не несколько частей:

- Системные файлы и директории (файлы и директории, объявленные при создании проекта, и необходимые для его полноценного функционирования)
-  Сервисные директории (к этой части относятся директории и вложенные файлы, такие как Services, ViewModels, Models, Migrations, DataServices)
- Пользовательские директории: не обязательно публичные (к данной части относятся пипки и вложенные файлы wwwroot, Controllers, Views)

Рассмотрим их поподробнее.

Сервисные файлы и директории

Класс Startup

Первым в описании и первым при запуске является класс Startup. В классе Startup объявляются файлы пользовательских настроек, добавляются зависимости (зависимостей библиотек с приложением), DI, Routing и т.д.

В конструкторе класса обозначаются конфигурационные файлы, секреты и т.д. В конфигурационные файлы вносятся такие данные как строка подключения к БД (см. описание к классу 5.1.1.1) или пароли для доступа к БД (User secret).

"Data": {
    	"DefaultConnection": {
         "ConnectionString": "Data Source=MYPC;Initial Catalog=AppleStore;
Integrated Security=True"
    	}
}
			Описание 5.1.1.1 отрывок кода из appsettings.json

В методе Configure включаются какие-либо Middleware в последовательность обработки HTTP запросов, а также настраивается routing (см. описание к классу 5.1.1.2).

     app.UseCookieAuthentication((cookieOptions) =>
            {
                cookieOptions.AutomaticAuthenticate = true;
                cookieOptions.AutomaticChallenge = true;
                cookieOptions.CookieName = ".StoreCookie";
            });
            
     app.UseMvc(routes =>
            {
                routes.MapRoute(
                    name: "default",
                    template: "{controller=Home}/{action=Index}/{id?}")
                    .MapRoute(
                    name: "api",
                    template: "api/{controller=Apple}/{action=Index}/{id?}");
            });
      }
		Описание 5.1.1.2 метод Configure из класса Startup

В методе ConfigureServices объявляются контексты подключения для работы с БД (ApplicationContext, StoreContext), роли пользователей (IdentityRoule), зависимости библиотек с приложением (AddMvc(), AddSession() и т.д.), а также внедрение зависимостей (DI) (см. описание к классу 5.1.1.3).

     services.AddTransient<IEmailSender, MessageService>();
            services.AddTransient<ISmsSender, MessageService>();
            services.AddScoped<IStoreContext, StoreContext>();
        services.AddTransient<IAppleRepository<Apple>, AppleRepository>();
			Описание 5.1.1.3 отрывок кода метода ConfigureServices (DI)

Файл gulpfile.js

Gulp (gulpfile.js см. описание к классу 5.1.2.1) - это инструментарий для работы с кодом со стороны клиента. Он обычно используется для передачи файлов со стороны клиента через серию процессов, когда вызывается конкретное событие в среде build. Некоторые преимущества использования Gulp заключаются в автоматизации общих задач по разработке, в упрощении повторяющихся задач и уменьшении временных затрат на разработку. Например, Gulp может использоваться для автоматизации “building and minification” или для очистки среды разработки перед новой сборкой.

paths.js = paths.webroot + "js/**/*.js";
paths.minJs = paths.webroot + "js/**/*.min.js";
paths.css = paths.webroot + "css/**/*.css";
paths.minCss = paths.webroot + "css/**/*.min.css";
paths.concatJsDest = paths.webroot + "js/site.min.js";
paths.concatCssDest = paths.webroot + "css/site.min.css";
		Описание 5.1.2.1 отрывок кода из gulpfile.js

Файл project.json

Project.json (см. описание к классу 5.1.3.1) используется, чтобы определить server side зависимости проекта (описанные ниже), а также другую информацию для конкретного проекта. Раздел webroot указывает папку, которая будет корнем веб-сайта. Раздел version указывает версию проекта. Раздел frameworks указывает, для каких фреймворков будет построен проект, и то, какие зависимости должны быть включены. Раздел exclude используется для указания файлов и папок, которые должны быть исключены из сборки.

"dependencies": {
        "angularjs": "1.4.6",
        "AngularJS.Animate": "1.4.6",
        "Currency": "",
        "EntityFramework.Commands": "7.0.0-rc1-final",
        "EntityFramework.Core": "7.0.0-rc1-final",
        "Microsoft.AspNet.Authentication.Cookies": "1.0.0-rc1-final",
        "Microsoft.AspNet.Diagnostics.Entity": "7.0.0-rc1-final",
        "Microsoft.AspNet.Identity": "3.0.0-rc1-final",
        "Microsoft.AspNet.Identity.EntityFramework": "3.0.0-rc1-final",
        "Microsoft.AspNet.Mvc": "6.0.0-rc1-final",
        "Microsoft.AspNet.Mvc.TagHelpers": "6.0.0-rc1-final",
        "Microsoft.AspNet.Server.Kestrel": "1.0.0-rc1-final",
        "Microsoft.AspNet.Server.WebListener": "1.0.0-rc1-final",
        "Microsoft.AspNet.Session": "1.0.0-rc1-final",
        "Microsoft.AspNet.StaticFiles": "1.0.0-rc1-final",
        "Microsoft.Extensions.Configuration.UserSecrets": "1.0.0-rc1-final",
 "Store.Entity": "",
        "Store.Repository": "",
        "Twilio": "4.5.0"
}
			Описание 5.1.3.1 отрывок кода из project.json

В зависимостях (dependencies) подключены библиотеки находящиеся в данном проекте (Store.Entity, Store.Repository, Currency),  AspNet.Mvc, TagHalpers, WebListener, EntityFramework, Kestrel, а также такие фреймворки как AngularJS, Angular Animate и библиотека для подключения отправки смдля подтверждения или уведомления – Twilio.


В сервисных директориях находятся как вспомогательные классы, так и сущности, созданные по умолчанию в приложении Web Application (MVC). К таким относятся директории ViewModels, Models, Migrations.

Директория ViewModels

В директории ViewModels находятся сущности для регистрации пользователя, изменения данных или авторизации пользователя.

В основном вся сущность осталась без изменений, за исключением RegisterViewModel (см. описание к классу 5.1.4.1). 

 [Required]
        [RegularExpression(pattern: @"[a-zA-Zа-яА-Я0-9_\- ]{2,15}$")]
        [StringLength(maximumLength: 15, MinimumLength = 2)]
        [Display(Name = "User name")]
        public String UserName { get; set; }

        [Required]
        [RegularExpression(pattern: @"[a-zA-Zа-яА-Я0-9_\- ]{2,15}$")]
        [StringLength(maximumLength: 15, MinimumLength = 2)]
        public String City { get; set; }

        [Required]
        [RegularExpression(@"^\+?[0-9]{3,5}-?[0-9\-]+$")]
        public String Phone { get; set; }

        [Required]
        [RegularExpression(pattern: @"[^<>!{}]+")]
        [StringLength(maximumLength: 40, MinimumLength = 5)]
    public String Address { get; set; }
			Описание 5.1.4.1 изменения в классе RegisterViewModel

В класс RegisterViewModel были добавлены поля:

- строковое поле UserName с валидацией от 2-х до 15-ти символов, и регулярным выражением позволяющим пропускать для записи в БД лишь буквы, цифры и некоторые символы (во избежания записи вредоносного кода)
- строковое поле Phone с регулярным выражением позволяющим пропускать лишь плюс (в начале), цифры и местами тире.
- строковое поле Address с регулярным выражением не позволяющим пропускать символы ^<>!{} во избежания записи вредоносного кода.

В директории Services находятся стандартные классы при создании MVC приложения (IEmailSender, ISmsSender и MessageService). Класс MessageService не используется. Интерфейсы ISmsSender и IEmailSender били изменены (см. описания к классам 5.1.4.2 и 5.1.4.3).

Task SendEmailAsync(string email, string subject, string message);
Task SendEmailToConfirm(String email, String subject, String key, String userName, String userID);
		Описание 5.1.4.2 изменения в интерфейсе IEmailSender

Task SendSmsAsync(string number, string message);
		Описание 5.1.4.3 изменения в интерфейсе ISmsSender

В интерфейсе IEmailSender в методы передаются такие данные:
- строка email с адресом получателя
- строка subject с объектом передаваемого сообщения
- строка message с сообщением, передаваемым в теле письма
- строка key с ключом для подтверждения регистрации пользователя через почтовый ящик
- строка userName с именем регистрирующегося пользователя
- строка userID с ID временно внесенного пользователя в систему

Директория Services

В директории Services, в поддиректории MessageSender присутствуют три класса: AuthMessageSmsSenderOptions и AuthMessageSenderOptions предназначены для хранения ключей и паролей к телефонному аккаунту и почтовому ящику, соответственно.

Класс MessageService предназначен для отправки смс и почты (см. пример к классам 5.1.5.1).

MailMessage mess = new MailMessage();
            mess.To.Add(new MailAddress(email,userName));
            mess.From = new MailAddress("***********@gmail.com", "VS Shop");
            mess.Subject = subject;
            String message = "Please Confirm email to finish registration";
            String url = "<a href='http://localhost:3923/Auth/ConfirmEmail/" + key +"?userID=" +userID+"' rel='link' title='Confirm Email'>Link!</a>";
            String html = @"<p>Hello "+userName+"</p></br><br/>" + url;
            mess.AlternateViews.Add(AlternateView.CreateAlternateViewFromString(message, null, MediaTypeNames.Text.Plain));
            mess.AlternateViews.Add(AlternateView.CreateAlternateViewFromString(html, null, MediaTypeNames.Text.Html));
            SmtpClient smtpClient = new SmtpClient("smtp.gmail.com", Convert.ToInt32(587));
            System.Net.NetworkCredential credentials = new System.Net.NetworkCredential("********@gmail.com", "**********");
            smtpClient.Credentials = credentials;
            smtpClient.EnableSsl = true;

            try
            {
                smtpClient.Send(mess);
            }
            catch (Exception ex)
            {
                String error = ex.Message;
                throw new Exception(ex.Message);
            }

	Описание 5.1.5.1 фрагмент класса MessageService – метод SendEmailToConfirm

В описании для класса  5.1.5.1 показан пример метода для подтверждения почтового ящика при регистрации. В строку “url” добавляется адрес для обратного перехода с email и хешированный ключ для подтверждения. Пока пользователь не перешел по выданной ссылке – ключ хранится в сессии приложения.

Метод SendSmsAsync отправляет смс (Short message sender) с зарегистрированного в системе Twilio номера телефона (телефон должен быть проплачен). В метод передаются два строковых поля: number и message. Number – это номер получателя. Message – тело сообщения.

Директория Model

В директории Model находятся два класса: ApplicationDbContext и ApplicationUser. ApplicationDbContext – это контекст используемый для регистрации, авторизации и аутентификации. ApplicationUser – является хранилищем пользователей и включает базовые методы (Create, Update, Delete) для работы с ними.

В класс ApplicationUser были добавлены два поля – City и Address, которые являются строковыми. У поля City максимальная длинна 20 символов и у поля Address максимальная длинна 40 символов.

Директория Migrations

Директория Migrations вмещает в себя миграций при изменении классов составляющих собой модель. Данная папка предназначена для хранения созданных миграций созданных пользователем.

Директория DataServices

Директория DataServices состоит из четырех директорий:
- Cart
- Currency
- MD5Hash
- RegisterLogin

Директория  RegisterLogin содержит класс RegisterLoginErrorsLanguage и интерфейс IRegisterLoginErrorsLanguage (см. описание к классу 5.1.8.1).
public interface IRegisterLoginErrorsLanguage
    {
        String Registration(ICollection<ModelStateEntry> modelState, String language);
        String Login(ICollection<ModelStateEntry> modelState, String language);
}
			Описание 5.1.8.1 интерфейс IRegisterLoginErrorsLanguage

Интерфейс и класс предназначены для обработки и сбора сообщений с ошибками при авторизации или регистрации. К примеру в классе RegisterLoginErrorsLanguage присутствует дополнительный метод RegisterMessage. Метод принимает две строковые переменные: сообщение с ошибкой и текущий язык. После проверяет наличие текущего сообщения и если такое присутствует – сообщение заменяется более подходящим. Интерфейс предназначен для объявления класса через DI.

Директория MD5Hash содержит класс MD5Hash и интерфейс IMD5Hash. Интерфейс IMD5Hash определяет один метод (VirifyHashPassword) и наследует интерфейс IPasswordHasher параметризированный классом ApplicationUser. Класс, в свою очередь, реализует три метода из интерфейса: HashPassword, VerifyHashedPassword и VirifyHashedPassword. Метод HashedPassword создает хешированный пароль из строки пароля и класса ApplicationUser. Метод VerifyHashedPassword сравнивает два пароля с помощью класса ApplicationUser и двух паролей: введенного пользователем и хешированного (сохраненного в БД). Третий метод (VirifyHashedPassword) сравнивает два хешированных пароля. Интерфейс IMD5Hash предназначен для объявления класса MD5Hash с помощью DI.

Поддиректория Currency в директории DataServices содержит интерфейсы и классы для получения последнего курса валют (либо сегодняшнего с базы данных, либо последнего с сайта Приват Банка).

В директории находятся следующие интерфейсы:
- ICurrency (см. пример класса 5.1.8.2)
- ICurrencyCurrent (см. пример класса 5.1.8.3)
- ICurrencyFactory (см. пример класса 5.1.8.4)
- ICurrencyLast (см. пример класса 5.1.8.5)

public interface ICurrency
    {
        Task<Decimal> GetCurrency();
}
	Описание 5.1.8.2 интерфейс ICurrency

public interface ICurrencyCurrent
    {
        String GetCurrentDateCurrency();
}
	Описание 5.1.8.3 интерфейс ICurrencyCurrent

    public interface ICurrencyFactory
    {
        ICurrencyCurrent current { get; set; }
        ICurrencyLast last { get; set; }
    }
	Описание 5.1.8.4 интерфейс ICurrencyFactory

public interface ICurrencyLast
    {
        void GetLastCurrencyFromPB();
        Task<Boolean> DateExist();
        void CreateCurrency();
        Decimal GetCurrency();
}
	Описание 5.1.8.5 интерфейс ICurrencyLast

В директории находятся соответствующие по именам классы:
- Currency
- CurrencyCurrent
- CurrencyFactory
- CurrencyLast

Класс CurrencyCurrent реализует интерфейс ICurrencyCurrent и принимает в конструкторе интерфейс ICurrencyUSD (ICurrencyUSD описанный в пункте 4.2.1 предыдущей главы). Метод GetCurrentDateCurrency  получает либо текущий курс валют, либо пустоту (null).

Класс CurrencyLast реализует интерфейс ICurrencyLast и принимает в конструкторе два интерфейса – ICurrencyUSD и IUnitOfWork (IUnitOfWork описан в пункте 4.2.4 предыдущей главы). Метод CreateCurrency создает новую запись в БД. Метод DateExist определяет наличие записи с определенной датой. Метод GetCurrency отдает последний полученный курс валют. Метод GetLastCurrency получает последнюю доступную запись через API с сервера Приват Банка.

Класс CurrencyFactory принимает в своем конструкторе два интерфейса – ICurrencyCurrent и ICurrencyLast и присваивает их объявленным в классе аналогичным интерфейсам.

Класс Currency реализует интерфейс ICurrency. Конструктор класса принимает интерфейс ICurrencyFactory и объявляет его с помощью DI как класс CurrencyFactory.

Метод GetCurrency класса Currency, получает строковое значение курса валют из БД по текущей дате. Если полученное значение пустое, в таком случае отправляется запрос для получения последнего записанного, на сервере Приват Банка, значение. После чего проверяется по полученному результату с Приват Банка, сравнивается записи в БД, и если нет соответственной – происходит запись в БД последнего полученного курса валют.

 Поддиректория Cart, находящаяся в директории DataServices, содержит классы и интерфейсы, предназначенные для работы с корзиной. А именно:

- Получение списка товаров, с их количествами.
- Получение цен выбранных товаров.
- Получение выбранных товаров.
- Добавление или изменение количества товара.
- Удаление товара из корзины.

Вся корзина хранится в формате массива ключ-значение в сессии приложения. Сами таблицы товаров хранятся в БД и при надобности запрашиваются.

В директории Cart находятся два интерфейса:
- ICar (см. описание к классу 5.1.8.6)
- ICartData (см. описание к классу 5.1.8.7)

public interface ICart
    {
        void GetHttpContext(HttpContext context);
        Boolean AddCount(Int32 id, Int32 count);
        //Boolean AddPrice(Int32 id);
        Task<Apple[]> GetData();
        Dictionary<Int32, Int32> GetCounts();
        Task<Dictionary<Int32, Decimal>> GetPrice();
        Boolean RemoveItem(Int32 id);

        Boolean UpdateItemCount(Int32 id, Int32 count);
}
		Описание 5.1.8.6 интерфейс ICart

public interface ICartData
    {
        void GetContext(HttpContext context);
        Task<Dictionary<Int32,Decimal>> GetPrice();
        Dictionary<Int32, Int32> GetCount();
        void AddPrice(Dictionary<Int32, Decimal> data);
        void AddCount(Dictionary<Int32, Int32> data);
}
		Описание 5.1.8.7 интерфейс ICartData



 
Заключение

Основная задача, которая была поставлена, выполнена полностью- разработан готовый продукт для продаж в Интернете. 
Его характеристики:

-	интернет магазин разработан с адаптивным дизайном, который
позволяет совершать покупки с устройств, ширина экрана которых не менее 600 пикселей;
-	разработан удобный функционал для быстрого пользования;
-	визуально красивый дизайн и анимация улучшают восприятие сайта, что положительно влияет на продажи;
-	после оформления заказа пользователю приходит сообщение на почту с перечнем товаров и другой информацией;
-	на почтовый ящик магазина отправляется уведомление о новом заказе;
-	разработана административная часть сайта с быстрым и понятным функционалом;
-	страница заказов отображает новые заказы в режиме реального времени (без перезагрузки страницы).

Клиентская часть сайта разработана с красивым и самое главное – удобным дизайном позволяющим пользователю оперативно найти нужный товар и информацию о нем. Реализована возможность просматривать цену в разной валюте: украинских гривнах или американских долларах. Оформление заказа не требует усилий, так как корзина открывается во всплывающем окне, что позволяет не покидать страницу товара. Пользователь может перейти в интересующий его раздел сайта с верхней или нижней навигационной панели.

При авторизации пользователь запоминается сайтом на 30-ть дней. Также при оформлении заказа пользователю нет необходимости повторно заполнять информационные поля: форма автоматически заполняется и при необходимости редактируется. 

Для работников интернет магазина разработан удобный интерфейс для быстрой работы с данными (заказами и товарами). Просмотр новых заявок не составит затруднений, так как новые заказы добавляются на страницу в режиме реального времени. Они добавляются в начало списка со статусом «Новый» и временем, что позволяет отличить их от тех, что уже обрабатываются. Изменения происходящие с заказами (при удалении или отметке как о выполненном) происходят в режиме реального времени. 

В административной части сайта можно добавлять, редактировать и удалять товары. При добавлении товара выбирается соответствующий категории шаблон с уже существующим набором названий характеристик. Их можно добавлять, редактировать и удалять. 

В ходе разработки были на практике реализованы знания, полученные во время обучения, а также глубже изучены технологии Microsoft Asp.Net MVC 6, SignalR, AngularJS. Приобретены навыки работы с ними и взаимодействия этих технологий между собой. 







 
Перечень условных обозначений

Внедрение зависимости (Dependency injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» (Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

Entity Framework (EF) – это объектно-реляционный модуль сопоставления, позволяющий разработчикам .NET работать с реляционными данными с помощью объектов, специализированных для доменов. Это устраняет необходимость в написании большей части кода для доступа к данным, который требуется разработчикам.

Веб-сайт (сайт) - представляет собой совокупность страниц и сервисных модулей.

База данных (БД) - выполняет роль, автоматизированного хранилища для информационного наполнения и служебной информации системы.

Страница является функционально завершённым программным блоком, который предназначен для динамического генерирования визуальной информации, передаваемой браузеру посетителя. Веб-страницы генерируются по запросу посетителя на основе информационного наполнения (хранящегося в БД) и шаблонов (определяющих состав и внешний вид страницы).

Раздел сайта (раздел) – наиболее крупный структурный элемент, объединяющий страницы сайта по принципу формирования логически законченной группы информации.

Подраздел сайта (подраздел) – структурное объединение страниц сайта внутри одного из его разделов.

Всплывающее окно браузера – дополнительное окно браузера, которое открывается при клике/наведении на некоторых ссылках (в тексте ТЗ, при описании страниц, явно указаны случаи использования такого окна там, где это не указано – используется обычное окно браузера). Применяется в случаях, когда необходимо: отобразить трудно прогнозируемый объём информации (например, таблицу сравнения технических характеристик), либо дополнить или пояснить отображаемую в главном окне информацию (например, увеличенная версия фотографии). Как правило, такое окно имеет фиксированный размер и не содержит стандартных (для окна браузера) панелей меню и инструментов.

Кнопка – навигационный или другой управляющий элемент страницы, который отличается от гиперссылки только визуальным представлением.
 




Описание необходимых технических средств
(рекомендуемые требования)

Для функционирования комплекса "Электронный журнал" необходимо следующее оборудование:
Требования к аппаратным средствам 
и программному  обеспечению (ПО)
В качестве рабочей станции может быть использован любой компьютер, подключенный к локальной сети и оснащенный HTTP-браузером.
Сервер:
Для функционирования комплекса необходим сервер, со следующим программным обеспечением: 
•	Сервер HTTP "IIS" с поддержкой ASP.NET версии 6 либо WebListener, либо Kestrel 
•	СУБД "MS SQL" предпочтительно версии не ниже 2012г. 
•	Операционная система - предпочтительно Windows.
Характеристики сервера (минимальные требования): 
•	Процессор Intel Pentium II 300 
•	Оперативная память 128 Мбайт 
•	Жесткий диск объемом 4 Гб (UDMA-33)
•	Сетевая карта UTP 100 Мбит 

Локальная вычислительная сеть:
Для хорошей производительности необходимо иметь сеть с пропускной способностью не менее 30 Мбит. 

Процедура инсталляции

Какие файлы используются в ПО и описание их назначения?
•	Файлы с расширением .cs – код исполняемый на стороне сервера. 
•	Файл AppleStore.sql – процедура создания базы данных. 
Что необходимо для инсталляции?
ПО:
1.	Создать базу данных "AppleStore" и необходимых таблиц в ней с помощью файла AppleStore.sql.
2.	Распаковать файлы из архива VS.rar в серверную директорию.
Описание дополнительных настроек сопутствующего ПО:
3.	В файле appsettings.json изменить строку подключения к Базе Данных. Файл находится в директории approot\src\AppleStore.
4.	Добавить пользователя в Базу Данных AppleStore с ролями “SuprerAdmin”, “Admin”,”Client”.
5.	В файле MessageService.cs задать в соответствующие позиции данные почтового ящика для отправки и приема писем. Файл находится в директории approot\src\AppleStore\Services\MessageSender.
6.	Для добавления сотрудников – изменить у зарегистрированных пользователей статус пользователя.

Можно начинать работу!
 
Используемые источники

1.	http://dou.ua/lenta/articles/inside-ASPNET-5-part1/   -  DOU.ua

2.	http://dou.ua/lenta/articles/inside-ASPNET-5-part2/   -  DOU.ua

3.	https://habrahabr.ru/post/243667/#hosting  -  Habrahabr

4.	https://habrahabr.ru/post/243667/  -  Habrahabr

5.	https://habrahabr.ru/company/microsoft/blog/101121/  -  Habrahabr

6.	http://ain.ua/2015/12/23/623551  - AIN.ua

7.	https://msdn.microsoft.com/ru-ru/library/gg696460(v=vs.113).aspx  - MSDN

8.	http://www.cyberguru.ru/dotnet/csharp-net/csharp-news-page2.html  Cyberguru

9.	http://dotnet.today/ru/aspnet5-mvc6  DotNet.Today

10.	https://habrahabr.ru/post/227351/  -  Habrahabr

11.	https://ru.wikipedia.org/wiki/Внедрение_зависимости - Wikipedia

12.	https://msdn.microsoft.com/ru-ru/data/ef.aspx  - MSDN

13.	http://metanit.com/sharp/articles/mvc/11.php  - Metanit

14.	Книга - Design Patterns via C# (Александр Шевчук, Дмитрий Охрименко, Андрей Касьянов) 2015г.

15.	https://msdn.microsoft.com/ru-ru/library/s57a598e.aspx#aspnet_mvc  - Microsoft
